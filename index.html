<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chess by Felix Schmidt</title>
    <!-- Import chess.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --board-light: #e0e0e0;
            --board-dark: #4a7a9f;
            --highlight: rgba(255, 255, 0, 0.5);
            --last-move: rgba(155, 255, 0, 0.4);
            --text-color: #f0f0f0;
            --accent-color: #ffcc00;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* Header Area with Title and Image */
        #header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            width: 90vw;
            max-width: 600px;
        }

        h1 { 
            margin: 0; 
            font-size: 1.8rem; 
            text-align: left;
            flex-grow: 1;
        }

        #profile-pic {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid var(--accent-color);
            object-fit: cover;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        /* Status & Evaluation Bar */
        #info-panel {
            width: 90vw;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #status {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent-color);
            text-align: center;
            min-height: 25px;
        }

        #eval-container {
            display: flex;
            width: 100%;
            height: 25px;
            background-color: #444;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #666;
            position: relative;
        }

        #eval-bar-white {
            height: 100%;
            background-color: #fff;
            width: 50%;
            transition: width 0.5s ease-in-out;
        }

        #eval-text {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center; /* Center the score */
            align-items: center;
            font-size: 0.9rem;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0,0,0,0.8);
            pointer-events: none;
            color: #fff;
            z-index: 2;
        }
        
        /* Chess Board */
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 600px;
            max-height: 600px;
            border: 5px solid #333;
            user-select: none;
            position: relative;
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .square.light { background-color: var(--board-light); }
        .square.dark { background-color: var(--board-dark); }
        .square.highlight { background-color: var(--highlight) !important; }
        .square.last-move::after {
            content: ''; position: absolute; top:0; left:0; right:0; bottom:0;
            background-color: var(--last-move); pointer-events: none;
        }

        /* Pieces */
        .piece {
            width: 90%; height: 90%;
            cursor: grab; z-index: 10;
            transition: transform 0.1s;
        }
        .piece.dragging {
            cursor: grabbing; z-index: 1000; pointer-events: none;
        }

        /* Controls */
        #controls {
            display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;
        }
        button {
            padding: 8px 12px; font-size: 0.9rem;
            background-color: #333; color: white;
            border: 1px solid #555; cursor: pointer;
            border-radius: 4px; transition: background 0.2s;
            display: flex; align-items: center; gap: 5px;
        }
        button:hover { background-color: #444; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        #ai-thinking {
            display: none; font-size: 0.9rem; color: #aaa; margin-top: 5px;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="header">
            <h1>AI Chess by Felix Schmidt</h1>
            <img id="profile-pic" src="https://enzocage.de/code/chess/king.jpg" alt="Logo">
        </div>
        
        <div id="info-panel">
            <div id="status">White to move</div>
            <div id="eval-container">
                <div id="eval-bar-white"></div>
                <div id="eval-text">0.0</div>
            </div>
        </div>

        <div id="board"></div>
        <div id="ai-thinking">AI is thinking...</div>
        
        <div id="controls">
            <button onclick="resetGame()">New Game</button>
            <button onclick="navigateHistory(-1)">&#9664; Prev</button>
            <button onclick="navigateHistory(1)">Next &#9654;</button>
            <button onclick="flipBoard()">Flip Board</button>
        </div>
    </div>

<script>
    // --- 1. IMPROVED GRAPHICS (BETTER KNIGHTS) ---
    const PIECES_SVG = {
        w: {
            p: '<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#fff" stroke="#000" stroke-width="1.5"/></svg>',
            r: '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5" stroke-linecap="butt"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" fill="none" stroke-linejoin="miter"/></g></svg>',
            n: '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21"/><path d="M24 18c.38 2.32-4.68 1.97-5 4 4.55 5.2 7.21 6.95 8.5 7.12.5-1.5-1-3-1.87-4.14-.87-1.13-1.7-2.32-2.63-3.98-.93-1.65-2.5-2-4-2z" fill="#fff" stroke="#000"/><path d="M9.5 25.5A23 23 0 0 1 15 29H9.5a7 7 0 0 0 0-3.5z" fill="#fff" stroke="#000"/><path d="M15 15.5c-4.55 1.5-6.5 4.5-7 8.5" fill="none"/><path d="M9.5 25.5A7 7 0 0 1 6 22l3.5 3.5z" fill="#fff" stroke="#000"/></g></svg>',
            b: '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#fff" stroke="#000" stroke-linecap="butt"><path d="M9 36c3.39-.47 12.42-4.18 19.98 2.56L28 36H9z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke-linejoin="miter"/></g></svg>',
            q: '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM10.5 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM38.5 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0z"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z"/><path d="M9 26c0 2 1.5 2 2.5 4 1 2.5 3 1 5 2.5a10.2 10.2 0 0 1 11.77 0c2-1.5 4 0 5-2.5 1-2 2.5-2 2.5-4H9z"/><path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0"/></g></svg>',
            k: '<svg viewBox="0 0 45 45"><g fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-1-5 2-8 2s-4-4-7.5-4-7.5 4-7.5 4-4-3-8-2c-3 6 6 10.5 6 10.5v7z"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/></g></svg>'
        },
        b: {
            p: '<svg viewBox="0 0 45 45"><path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#000" stroke="#fff" stroke-width="1.5"/></svg>',
            r: '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5" stroke-linecap="butt"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5H14V17" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/><path d="M11 14h23" fill="none" stroke-linejoin="miter"/></g></svg>',
            n: '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#000"/><path d="M24 18c.38 2.32-4.68 1.97-5 4 4.55 5.2 7.21 6.95 8.5 7.12.5-1.5-1-3-1.87-4.14-.87-1.13-1.7-2.32-2.63-3.98-.93-1.65-2.5-2-4-2z" fill="#fff" stroke="#fff"/><path d="M9.5 25.5A23 23 0 0 1 15 29H9.5a7 7 0 0 0 0-3.5z" fill="#fff" stroke="#fff"/><path d="M15 15.5c-4.55 1.5-6.5 4.5-7 8.5" fill="none" stroke="#fff"/><path d="M9.5 25.5A7 7 0 0 1 6 22l3.5 3.5z" fill="#fff" stroke="#fff"/></g></svg>',
            b: '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#000" stroke="#fff" stroke-linecap="butt"><path d="M9 36c3.39-.47 12.42-4.18 19.98 2.56L28 36H9z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke-linejoin="miter"/></g></svg>',
            q: '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM10.5 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM38.5 20a2 2 0 1 1-4 0 2 2 0 1 1 4 0z"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-13.5V25L7 14l2 12z"/><path d="M9 26c0 2 1.5 2 2.5 4 1 2.5 3 1 5 2.5a10.2 10.2 0 0 1 11.77 0c2-1.5 4 0 5-2.5 1-2 2.5-2 2.5-4H9z"/><path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0"/></g></svg>',
            k: '<svg viewBox="0 0 45 45"><g fill="#000" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-1-5 2-8 2s-4-4-7.5-4-7.5 4-7.5 4-4-3-8-2c-3 6 6 10.5 6 10.5v7z"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/></g></svg>'
        }
    };

    // --- 2. SETUP & STATE ---
    const game = new Chess();
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const aiThinkingEl = document.getElementById('ai-thinking');
    const evalBarWhite = document.getElementById('eval-bar-white');
    const evalTextEl = document.getElementById('eval-text');
    
    let draggedPiece = null;
    let startSquare = null;
    let boardOrientation = 'w';
    
    // History Navigation
    let redoStack = []; // Stack for forward moves
    
    // --- 3. SIGNIFICANTLY IMPROVED AI LOGIC ---

    const PIECE_VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
    const transpositionTable = new Map();
    const TT_EXACT = 0, TT_ALPHA = 1, TT_BETA = 2;
    
    // Killer Moves: [depth][move_slot]
    let killerMoves = [];
    const MAX_DEPTH = 4; // Search depth

    // Improved PST (Simplified for brevity but solid)
    const PST = {
        p: [ 0, 0, 0, 0, 0, 0, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 10, 10, 20, 30, 30, 20, 10, 10, 5, 5, 10, 25, 25, 10, 5, 5, 0, 0, 0, 20, 20, 0, 0, 0, 5, -5,-10, 0, 0,-10, -5, 5, 5, 10, 10,-20,-20, 10, 10, 5, 0, 0, 0, 0, 0, 0, 0, 0 ],
        n: [ -50,-40,-30,-30,-30,-30,-40,-50, -40,-20, 0, 0, 0, 0,-20,-40, -30, 0, 10, 15, 15, 10, 0,-30, -30, 5, 15, 20, 20, 15, 5,-30, -30, 0, 15, 20, 20, 15, 0,-30, -30, 5, 10, 15, 15, 10, 5,-30, -40,-20, 0, 5, 5, 0,-20,-40, -50,-40,-30,-30,-30,-30,-40,-50 ],
        b: [ -20,-10,-10,-10,-10,-10,-10,-20, -10, 0, 0, 0, 0, 0, 0,-10, -10, 0, 5, 10, 10, 5, 0,-10, -10, 5, 5, 10, 10, 5, 5,-10, -10, 0, 10, 10, 10, 10, 0,-10, -10, 10, 10, 10, 10, 10, 10,-10, -10, 5, 0, 0, 0, 0, 5,-10, -20,-10,-10,-10,-10,-10,-10,-20 ],
        r: [ 0, 0, 0, 0, 0, 0, 0, 0, 5, 10, 10, 10, 10, 10, 10, 5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, 0, 0, 0, 5, 5, 0, 0, 0 ],
        q: [ -20,-10,-10, -5, -5,-10,-10,-20, -10, 0, 0, 0, 0, 0, 0,-10, -10, 0, 5, 5, 5, 5, 0,-10, -5, 0, 5, 5, 5, 5, 0, -5, 0, 0, 5, 5, 5, 5, 0, -5, -10, 5, 5, 5, 5, 5, 0,-10, -10, 0, 5, 0, 0, 0, 0,-10, -20,-10,-10, -5, -5,-10,-10,-20 ],
        k: [ -30,-40,-40,-50,-50,-40,-40,-30, -30,-40,-40,-50,-50,-40,-40,-30, -30,-40,-40,-50,-50,-40,-40,-30, -30,-40,-40,-50,-50,-40,-40,-30, -20,-30,-30,-40,-40,-30,-30,-20, -10,-20,-20,-20,-20,-20,-20,-10, 20, 20, 0, 0, 0, 0, 20, 20, 20, 30, 10, 0, 0, 10, 30, 20 ]
    };
    const PST_K_END = [ -50,-40,-30,-20,-20,-30,-40,-50, -30,-20,-10, 0, 0,-10,-20,-30, -30,-10, 20, 30, 30, 20,-10,-30, -30,-10, 30, 40, 40, 30,-10,-30, -30,-10, 30, 40, 40, 30,-10,-30, -30,-10, 20, 30, 30, 20,-10,-30, -30,-30, 0, 0, 0, 0,-30,-30, -50,-30,-30,-30,-30,-30,-30,-50 ];

    function evaluateBoard(fen) {
        const tempGame = new Chess(fen);
        let score = 0;
        const board = tempGame.board();
        let isEndgame = !fen.includes('q') && !fen.includes('Q'); 

        // 1. Material & PST
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                const piece = board[i][j];
                if (!piece) continue;
                
                let val = PIECE_VALUES[piece.type];
                let pstIdx = i * 8 + j;
                let pstVal = 0;

                if (piece.color === 'w') {
                    pstVal = (piece.type === 'k' && isEndgame) ? PST_K_END[pstIdx] : PST[piece.type][pstIdx];
                    score += (val + pstVal);
                } else {
                    let mirrorIdx = (7 - i) * 8 + j; 
                    pstVal = (piece.type === 'k' && isEndgame) ? PST_K_END[mirrorIdx] : PST[piece.type][mirrorIdx];
                    score -= (val + pstVal);
                }
            }
        }

        // 2. Mobility (Simple: Count pseudo-legal moves)
        const moves = tempGame.moves();
        const mobilityBonus = moves.length * 5; 
        score += (tempGame.turn() === 'w' ? mobilityBonus : -mobilityBonus);

        // Return score relative to the side to move
        return score * (tempGame.turn() === 'w' ? 1 : -1);
    }

    function orderMoves(moves, bestMoveFromTT, depth) {
        return moves.sort((a, b) => {
            if (bestMoveFromTT && a.san === bestMoveFromTT.san) return -100000;
            if (bestMoveFromTT && b.san === bestMoveFromTT.san) return 100000;

            let scoreA = 0, scoreB = 0;
            if (a.captured) scoreA += 10 * PIECE_VALUES[a.captured] - PIECE_VALUES[a.piece];
            if (a.promotion) scoreA += PIECE_VALUES[a.promotion];
            if (b.captured) scoreB += 10 * PIECE_VALUES[b.captured] - PIECE_VALUES[b.piece];
            if (b.promotion) scoreB += PIECE_VALUES[b.promotion];

            if (killerMoves[depth]) {
                if (killerMoves[depth][0] === a.san) scoreA += 900;
                else if (killerMoves[depth][1] === a.san) scoreA += 800;
                if (killerMoves[depth][0] === b.san) scoreB += 900;
                else if (killerMoves[depth][1] === b.san) scoreB += 800;
            }
            return scoreB - scoreA;
        });
    }

    function storeKillerMove(move, depth) {
        if (!killerMoves[depth]) killerMoves[depth] = [null, null];
        if (killerMoves[depth][0] !== move.san) {
            killerMoves[depth][1] = killerMoves[depth][0];
            killerMoves[depth][0] = move.san;
        }
    }

    function quiescence(alpha, beta) {
        let standPat = evaluateBoard(game.fen());
        if (standPat >= beta) return beta;
        if (alpha < standPat) alpha = standPat;
        
        let moves = game.moves({ verbose: true }).filter(m => m.captured);
        moves = orderMoves(moves, null, 0); 
        
        for (let move of moves) {
            game.move(move);
            let score = -quiescence(-beta, -alpha);
            game.undo();
            if (score >= beta) return beta;
            if (score > alpha) alpha = score;
        }
        return alpha;
    }

    function negamax(depth, alpha, beta, pliesFromRoot) {
        const fen = game.fen();
        let ttEntry = transpositionTable.get(fen);
        
        if (ttEntry && ttEntry.depth >= depth) {
            if (ttEntry.flag === TT_EXACT) return ttEntry.value;
            if (ttEntry.flag === TT_ALPHA && ttEntry.value <= alpha) return alpha;
            if (ttEntry.flag === TT_BETA && ttEntry.value >= beta) return beta;
        }

        if (depth === 0) return quiescence(alpha, beta);

        let moves = game.moves({ verbose: true });
        if (moves.length === 0) {
            if (game.in_check()) return -20000 + pliesFromRoot; 
            return 0; 
        }

        moves = orderMoves(moves, ttEntry ? ttEntry.bestMove : null, depth);

        let bestMove = null;
        let bestValue = -Infinity;
        let originalAlpha = alpha;

        for (let move of moves) {
            game.move(move);
            let score = -negamax(depth - 1, -beta, -alpha, pliesFromRoot + 1);
            game.undo();

            if (score > bestValue) {
                bestValue = score;
                bestMove = move;
            }
            if (score > alpha) {
                alpha = score;
                if (!move.captured) storeKillerMove(move, depth);
            }
            if (alpha >= beta) break; 
        }

        let ttFlag = TT_EXACT;
        if (bestValue <= originalAlpha) ttFlag = TT_ALPHA;
        else if (bestValue >= beta) ttFlag = TT_BETA;

        transpositionTable.set(fen, {
            depth: depth,
            value: bestValue,
            flag: ttFlag,
            bestMove: bestMove
        });

        return bestValue;
    }

    function updateEvaluationUI(cpScore) {
        // Correctly calculate White's score based on who just moved
        // If turn is 'w', it means Black just moved, so cpScore (which is relative to mover) is Black's score.
        // We want White's score, so we invert it.
        // If turn is 'b', it means White just moved, so cpScore is White's score.
        let whiteScore = game.turn() === 'w' ? -cpScore : cpScore;
        
        // Handle Mate
        if (Math.abs(whiteScore) > 10000) {
            const isWhiteWinning = whiteScore > 0;
            // Approximate moves to mate (20000 - score)
            const movesToMate = Math.ceil((20000 - Math.abs(whiteScore)) / 2);
            evalTextEl.innerText = `M${movesToMate}`;
            evalBarWhite.style.width = isWhiteWinning ? '100%' : '0%';
            return;
        }

        // Standard Centipawn Display
        let evalDisplay = (whiteScore / 100).toFixed(1);
        if (evalDisplay > 0) evalDisplay = "+" + evalDisplay;
        evalTextEl.innerText = evalDisplay;

        // Calculate winning percentage using a sigmoid function
        // 180 divisor provides a good steepness (roughly +1.8 pawns = 73%, +5 pawns = 95%)
        let winChance = 1 / (1 + Math.exp(-whiteScore / 180));
        let whitePercent = Math.round(winChance * 100);

        evalBarWhite.style.width = `${whitePercent}%`;
    }

    function makeBestMove() {
        const moves = game.moves();
        if (game.game_over() || moves.length === 0) return;

        aiThinkingEl.style.display = 'block';
        
        setTimeout(() => {
            let bestMove = null;
            let bestScore = -Infinity;
            killerMoves = []; 

            for (let d = 1; d <= MAX_DEPTH; d++) {
                aiThinkingEl.innerText = `AI thinking (Depth: ${d})...`;
                let alpha = -Infinity;
                let beta = Infinity;
                let currentBestMove = null;
                let currentBestScore = -Infinity;

                let allMoves = game.moves({ verbose: true });
                let ttEntry = transpositionTable.get(game.fen());
                allMoves = orderMoves(allMoves, ttEntry ? ttEntry.bestMove : null, d);

                for (let move of allMoves) {
                    game.move(move);
                    let score = -negamax(d - 1, -beta, -alpha, 1);
                    game.undo();

                    if (score > currentBestScore) {
                        currentBestScore = score;
                        currentBestMove = move;
                    }
                    if (score > alpha) alpha = score;
                }
                
                bestMove = currentBestMove;
                bestScore = currentBestScore;
            }

            // updateEvaluationUI expects the score of the side that JUST moved (the AI)
            // If AI is Black, bestScore is positive if Black is winning.
            updateEvaluationUI(bestScore);

            if (bestMove) {
                game.move(bestMove);
                redoStack = []; 
                renderBoard();
                checkStatus();
            }
            aiThinkingEl.style.display = 'none';
        }, 50);
    }


    // --- 4. BOARD & INTERACTION ---

    function renderBoard() {
        boardEl.innerHTML = '';
        const boardState = game.board();
        
        const rows = boardOrientation === 'w' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];
        const cols = boardOrientation === 'w' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];

        rows.forEach(i => {
            cols.forEach(j => {
                const square = document.createElement('div');
                square.className = `square ${(i + j) % 2 === 0 ? 'light' : 'dark'}`;
                square.dataset.square = String.fromCharCode(97 + j) + (8 - i);
                
                const pieceInfo = boardState[i][j];
                if (pieceInfo) {
                    const piece = document.createElement('div');
                    piece.className = 'piece';
                    piece.innerHTML = PIECES_SVG[pieceInfo.color][pieceInfo.type];
                    piece.draggable = true;
                    piece.dataset.square = square.dataset.square; 
                    piece.dataset.color = pieceInfo.color;
                    square.appendChild(piece);
                }
                
                square.addEventListener('dragover', (e) => e.preventDefault());
                square.addEventListener('drop', handleDrop);
                square.addEventListener('mousedown', handleMouseDown);
                
                const history = game.history({ verbose: true });
                if (history.length > 0) {
                    const last = history[history.length - 1];
                    if (square.dataset.square === last.from || square.dataset.square === last.to) {
                        square.classList.add('last-move');
                    }
                }
                boardEl.appendChild(square);
            });
        });
        setupTouchEvents();
    }

    function handleMouseDown(e) {
        const piece = e.target.closest('.piece');
        if (!piece || (piece.dataset.color !== 'w' && game.turn() === 'w')) return;
        if(game.game_over()) return;

        startSquare = piece.dataset.square;
        draggedPiece = piece;
    }

    document.addEventListener('dragstart', (e) => {
        if (!e.target.closest('.piece')) { e.preventDefault(); return; }
        if (game.turn() === 'b') { e.preventDefault(); return; } 
        draggedPiece = e.target.closest('.piece');
        startSquare = draggedPiece.dataset.square;
        setTimeout(() => draggedPiece.classList.add('dragging'), 0);
        highlightMoves(startSquare);
    });

    document.addEventListener('dragend', () => {
        if (draggedPiece) draggedPiece.classList.remove('dragging');
        clearHighlights();
        draggedPiece = null;
    });

    function handleDrop(e) {
        e.preventDefault();
        const targetSquare = e.target.closest('.square');
        if (!targetSquare || !startSquare) return;
        attemptMove({ from: startSquare, to: targetSquare.dataset.square, promotion: 'q' });
    }

    let touchPiece, touchStartX, touchStartY;
    function setupTouchEvents() {
        document.querySelectorAll('.piece').forEach(p => {
            p.addEventListener('touchstart', (e) => {
                if (game.turn() !== 'w' || p.dataset.color !== 'w') return;
                e.preventDefault();
                touchPiece = p;
                startSquare = p.dataset.square;
                p.style.position = 'fixed'; p.style.zIndex = 1000;
                movePieceToTouch(e.touches[0]);
                highlightMoves(startSquare);
            }, {passive:false});
            p.addEventListener('touchmove', (e) => {
                if (touchPiece) { e.preventDefault(); movePieceToTouch(e.touches[0]); }
            }, {passive:false});
            p.addEventListener('touchend', (e) => {
                if (!touchPiece) return;
                touchPiece.style.position=''; touchPiece.style.zIndex='';
                touchPiece.hidden = true;
                let elem = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                touchPiece.hidden = false;
                let target = elem ? elem.closest('.square') : null;
                clearHighlights();
                if (target && startSquare) attemptMove({ from: startSquare, to: target.dataset.square, promotion: 'q' });
                touchPiece = null;
            });
        });
    }
    function movePieceToTouch(t) {
        if (touchPiece) {
            touchPiece.style.left = (t.clientX - touchPiece.offsetWidth/2)+'px';
            touchPiece.style.top = (t.clientY - touchPiece.offsetHeight/2)+'px';
        }
    }

    function highlightMoves(sq) {
        game.moves({ square: sq, verbose: true }).forEach(m => {
            document.querySelector(`.square[data-square="${m.to}"]`)?.classList.add('highlight');
        });
    }
    function clearHighlights() {
        document.querySelectorAll('.square').forEach(s => s.classList.remove('highlight'));
    }

    function attemptMove(move) {
        try {
            if (game.move(move)) {
                redoStack = []; 
                renderBoard();
                checkStatus();
                let quickEval = evaluateBoard(game.fen()); 
                // Quick eval is from side to move (now AI).
                // So if AI is winning (pos), quickEval is pos.
                updateEvaluationUI(quickEval);

                if (!game.game_over()) makeBestMove();
            }
        } catch(e) { renderBoard(); }
    }

    function navigateHistory(direction) {
        if (direction === -1) {
            let move = game.undo();
            if (move) {
                redoStack.push(move);
                renderBoard();
                checkStatus();
                let quickEval = evaluateBoard(game.fen()); 
                updateEvaluationUI(quickEval);
            }
        } else if (direction === 1) {
            let move = redoStack.pop();
            if (move) {
                game.move(move);
                renderBoard();
                checkStatus();
                let quickEval = evaluateBoard(game.fen()); 
                updateEvaluationUI(quickEval);
            }
        }
    }

    function checkStatus() {
        if (game.in_checkmate()) statusEl.innerText = game.turn() === 'w' ? "Black wins!" : "White wins!";
        else if (game.in_draw()) statusEl.innerText = "Draw";
        else if (game.in_check()) statusEl.innerText = "Check!";
        else statusEl.innerText = game.turn() === 'w' ? "Your Turn" : "AI Thinking...";
    }

    function flipBoard() {
        boardOrientation = boardOrientation === 'w' ? 'b' : 'w';
        renderBoard();
    }

    function resetGame() { 
        game.reset(); 
        transpositionTable.clear(); 
        redoStack = []; 
        killerMoves = [];
        renderBoard(); 
        checkStatus(); 
        updateEvaluationUI(0); 
    }
    
    renderBoard();
    updateEvaluationUI(0);

</script>
</body>
</html>